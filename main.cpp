/**
 * Minecraft shop script for managing a scoreboard based shop system.
 * Made by Dylan Beppu
 */


#include <iostream>
#include <string>
#include <fstream>
#include <cctype>
#include <sstream>


std::string SCOREBOARD_VALUE = "Money";
std::string ERROR_COLOR = "§c";
std::string SUCCESS_COLOR = "§a";
std::string ERROR_SOUND = "mob.villager.no";
std::string SUCCESS_SOUND = "mob.villager.yes";


std::string BuyItem(std::string array[4]);
std::string SellItem(std::string array[4]);


int main(int argc, char* argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: " << argv[0] << " <argument>" << std::endl;
        return 1;
    }

    std::string shopName = argv[1];
    std::string scriptOutputName =  shopName;



	//Strip the file extion if it exists
	int fileExtentionStart = shopName.rfind('.');
	if (fileExtentionStart != -1) {
		scriptOutputName = shopName.substr(0, fileExtentionStart);
	}
	scriptOutputName += "_script.txt";


	//Open the input file in read mode
    std::ifstream csvFile;
	csvFile.open(shopName);

	//Error checking
    if (!csvFile.is_open()) {
        std::cerr << "Error: Could not open file: " << shopName << std::endl;
        return 1;
    }

	//Open the output file in write mode
    std::ofstream scriptFile;
	scriptFile.open("script.txt");

	//Error checking
	if (!scriptFile.is_open()) {
		std::cerr << "Error: Could not create file: shop.csv" << std::endl;
		return 1;
	}

	// Read the contents of the CSV file and write to the script file
	std::string line;
	std::getline(csvFile, line); // Read the header line and ignore it
	
	scriptFile << "Auto generated by https://github.com/Dylan-Beppu/Minecraft-shop-script-thing" << std::endl;

	while (std::getline(csvFile, line)) {	
		// Split the line by commas into a array
		std::string array[4];
		std::string currSub;
		size_t commasFound = 0;

		//Separate everything by comma
		for(size_t i = 0; i < line.length(); i++) {	
			if (line[i] == ',') {
				array[commasFound] = currSub;
				commasFound++;
				currSub="";

			} else if(line[i] == ' ') {
				//Do nothing, ignore white space
			
			} else {
				currSub += std::tolower(static_cast<unsigned char>(line[i]));
			
			}
		}

		//Should be last, so shove the rest into the last part
		array[commasFound] = currSub;
	

		// Check if the action type is valid
		if (array[1] == "buy") {
			scriptFile << BuyItem(array);
		
		} else if (array[1] == "sell") {
			scriptFile << SellItem(array);

		} else {
			std::cerr << "Invalid action type on item: " << array[0] << std::endl;
		}




	}

	// Close the script file
	scriptFile.close();
    csvFile.close();

	std::cout << "Script file saved as: " << scriptOutputName << std::endl;

    return 0;
}


/**
 * Converts the input array to a sell script for a NPC
 * 
 * @param Array A string array with the format {item name, action type, cost, amount}
 * @return The script generated
 */
std::string SellItem(std::string array[4]) {
	std::stringstream retStream;
	int lowVal = std::stoi(array[2]) - 1;
	
	//New lines to separate this script from the prior script
	retStream << std::endl << std::endl;

	//Header for the script
	retStream << "\t" << array[0] << " - Sell" << std::endl;

	//Put error message if not enough curreny
	retStream <<  "/tell @initiator[scores={" << SCOREBOARD_VALUE << "=.." << lowVal << "}] " 
		<< ERROR_COLOR << "Not enough " << SCOREBOARD_VALUE << "§f" << std::endl;
	
	//Play error sound if not enough currency for player to buy item
	retStream <<  "/playsound " << ERROR_SOUND << " @initiator[scores={" << SCOREBOARD_VALUE 
		<< "=.." << lowVal << "}]"<< std::endl;

	//Give the player the item being sold
	retStream <<  "/give @initiator[scores={" << SCOREBOARD_VALUE << "=" << array[2] << "}] "
		<<  array[0] <<  " " << array[3] << std::endl;
	
	//Tell the player that they bought the item
	retStream <<  "/tell @initiator[scores={" << SCOREBOARD_VALUE << "=" << array[0] << "..}] "
		<< SUCCESS_COLOR << array[3] << " " << array[0] << " recieved§f" << std::endl;

	//Play sound if sale is sucscssfull
	retStream <<  "/playsound " << SUCCESS_SOUND << " @initiator[scores={" << SCOREBOARD_VALUE
		<< "=" << array[2] << "..}]" << std::endl;

	//Remove the sale cost from the player
	retStream <<  "/scoreboard players remove @initiator[scores={" << SCOREBOARD_VALUE << "="
		<< array[2] << "..}] " << SCOREBOARD_VALUE << " " << array[2] << std::endl;

	return retStream.str();

}



// item, buy/sell, cost, quantity

/**
 * Converts the input array to a buy script for a NPC
 * 
 * @param Array A string array with the format {item name, action type, cost, amount}
 * @return The script generated
 */
std::string BuyItem(std::string array[4]) {
	std::stringstream retStream;
	int lowQuantity = std::stoi(array[3]) - 1;

	//New lines to separate this script from the prior script
	retStream << std::endl << std::endl;

	//Header for the script
	retStream << "\t" << array[0] << " - Buy" << std::endl;

	//Put error message if not enough of an item
	retStream << "/tell @initiator[hasitem={item=" << array[0] << ",quantity=.." << lowQuantity << "=.."
		<< lowQuantity << "}] " << ERROR_COLOR << "Not enough " << array[0] << "§f" << std::endl;

	//Play sound if not enough of an item
	retStream << "/playsound "<< ERROR_SOUND << " @initiator[hasitem={item=" << array[0] 
		<< ",quantity=.." << lowQuantity << "}]" << std::endl;

	//Add money to player if enough item to sell
	retStream << "/scoreboard players add @initiator[hasitem={item=" << array[0] << ",quantity="
		<< array[3] << "..}] " << SCOREBOARD_VALUE << " " << array[3] << std::endl;

	//Play sound if enough items to sell
	retStream << "/playsound " << SUCCESS_SOUND << " @initiator[hasitem={item=" << array[0]
		<< ",quantity=" << array[3] << "..}]" << std::endl;

	//Put message that item has been sold
	retStream << "/tell @initiator[hasitem={item=" << array[0] << ",quantity=" << array[3]
		<< "..}] " << SUCCESS_COLOR << array[3] << " " << array[0] << "§f" << std::endl;

	//Remove the item from the players inventory
	retStream << "/clear @initiator[hasitem={item=" << array[0] << ",quantity=" << array[3]
		<< "..}] " << array[0] << " " << array[3] << std::endl;

	return retStream.str();
}




